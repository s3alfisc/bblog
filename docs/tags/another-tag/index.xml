<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>    <link>https://s3alfisc.github.io/blog/tags/another-tag/</link>
    <description>Recent blog posts by </description>    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 03 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://s3alfisc.github.io/blog/tags/another-tag/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Setting Random Seeds from R in Julia and Rcpp</title>
      <link>https://s3alfisc.github.io/blog/post/2022-03-16-setting-random-seeds-from-r-across-languages/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://s3alfisc.github.io/blog/post/2022-03-16-setting-random-seeds-from-r-across-languages/</guid>
   <description>


&lt;p&gt;Version 0.8 of &lt;code&gt;fwildclusterboot&lt;/code&gt; will allow to run the wild cluster bootstrap through algorithms implemented in three languages: &lt;code&gt;fwildclusterboot&#39;s&lt;/code&gt; initial implementation of the fast algorithm in R, a new memory-sensitive (but slow) implementation via rcpp and last, version 0.8 provides a binding to David Roodman’s &lt;code&gt;WildBootTests.jl&lt;/code&gt; package.&lt;/p&gt;
&lt;p&gt;As the bootstrap is a stochastic method, supporting algorithms implemented in multiple languages causes some challenges with random number generation.
One key design goal is to guarantee reproducibility across all three languages. Optimally, it should be possible to control stochastic behavior within Julia from R via the familiar &lt;code&gt;set.seed()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;On top of the language differences, &lt;code&gt;fwildclusterboot&#39;s&lt;/code&gt; ‘native’ implementation of the wild cluster bootstrap relies on the &lt;code&gt;dqrng&lt;/code&gt; package for fast random number generation for all supported weight types except for Mammen weights.&lt;/p&gt;
&lt;p&gt;To guarantee reproducibility of computations via &lt;code&gt;boottest()&lt;/code&gt; prior to version 0.8, it was therefore required to set a global seed via the &lt;code&gt;dqrng::dqset.seed&lt;/code&gt;function. For Mammen weights, an additional seed needed to be set via the familiar &lt;code&gt;set.seed()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;fwildclusterboot&lt;/code&gt; v0.8, it is now possible to control all random number generation in &lt;em&gt;both&lt;/em&gt; R and Julia via &lt;code&gt;set.seed()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is achieved by borrowing from an idea by &lt;a href=&#34;https://www.r-bloggers.com/2018/09/using-rs-set-seed-to-set-seeds-for-use-in-c-c-including-rcpp/&#34;&gt;Rory Nolan&lt;/a&gt;. He suggests to use another R function that &lt;em&gt;stochastically&lt;/em&gt; generates a random integer &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; &lt;em&gt;based on the current state of the global R seed&lt;/em&gt; - which is initially set via the familiar &lt;code&gt;set.seed()&lt;/code&gt; - and to then to use the generated integer as a seed value in either R, Julia or c++.&lt;/p&gt;
&lt;p&gt;Hence when using the Julia or c++ based algorithms, neither &lt;code&gt;set.seed(1234); boottest(..., seed = NULL);&lt;/code&gt; nor &lt;code&gt;boottest(..., seed = 1234)&lt;/code&gt; actually pass &lt;code&gt;1234&lt;/code&gt; as a seed value to Julia or c++. Instead, both create a new integer based on the state of R’s global seed, which is implicitly called by the &lt;code&gt;sample.int(.Machine$integer.max, 1)&lt;/code&gt; function.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:pressure&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;Van_Gogh_Enclosed_Field_with_Ploughman.jpg&#34; alt=&#34;Setting a seed - Enclosed field with Ploughman, Vincent Van Gogh&#34; width=&#34;75%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Setting a seed - Enclosed field with Ploughman, Vincent Van Gogh
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-julia-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;A Julia Example&lt;/h2&gt;
&lt;p&gt;In a first step, we define a function &lt;code&gt;stochastic_julia_fun&lt;/code&gt; that randomly samples an integer in Julia. The function has only one optional function argument, &lt;code&gt;seed&lt;/code&gt;, and we use the &lt;code&gt;JuliaConnectoR&lt;/code&gt; package to communicate between R and Julia.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(JuliaConnectoR)

stochastic_julia_fun &amp;lt;- function(seed = NULL){
  
  if(is.null(seed)){
    seed &amp;lt;- sample.int(.Machine$integer.max, 1)
    JuliaConnectoR::juliaEval(&amp;#39;using Random&amp;#39;)
    rng_char &amp;lt;- paste0(&amp;quot;Random.seed!(&amp;quot;, seed, &amp;quot;)&amp;quot;)
    JuliaConnectoR::juliaEval(rng_char)
  } else if(!is.null(seed)){
    set.seed(seed)
    seed &amp;lt;- sample.int(.Machine$integer.max, 1)
    JuliaConnectoR::juliaEval(&amp;#39;using Random&amp;#39;)
    rng_char &amp;lt;- paste0(&amp;quot;Random.seed!(&amp;quot;, seed, &amp;quot;)&amp;quot;)
    JuliaConnectoR::juliaEval(rng_char)
  }
  
  JuliaConnectoR::juliaEval(&amp;quot;using StatsBase&amp;quot;)
  x &amp;lt;- JuliaConnectoR::juliaEval(&amp;quot;sample(1:typemax(Int32))&amp;quot;)

  x
  
}

set.seed(1234)
stochastic_julia_fun()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1225195882&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stochastic_julia_fun(seed = 1234)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1225195882&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before creating a random number in Julia for the first time via &lt;code&gt;stochastic_julia_fun()&lt;/code&gt;, we set a seed in R through the &lt;code&gt;set.seed()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1234)
stochastic_julia_fun()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1225195882&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Within &lt;code&gt;stochastic_julia_fun()&lt;/code&gt;, the following steps are now executed:
as no seed has been directly provided, &lt;code&gt;stochastic_julia_fun()&lt;/code&gt; samples an integer &lt;em&gt;within&lt;/em&gt; R via the &lt;code&gt;sample()&lt;/code&gt; function, whose stochastic behavior is determined by the seed set via &lt;code&gt;set.seed(1234)&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;internal_seed &amp;lt;- sample.int(.Machine$integer.max, 1)
internal_seed&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 469344150&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a next step, the drawn integer is passed to Julia and used as the ‘global Julia-seed’, which then controls the random number generation in Julia.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;JuliaConnectoR::juliaEval(&amp;#39;using Random&amp;#39;)
rng_char &amp;lt;- paste0(&amp;quot;Random.seed!(&amp;quot;, internal_seed, &amp;quot;)&amp;quot;)
JuliaConnectoR::juliaEval(rng_char)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;Julia object of type TaskLocalRNG&amp;gt;
## TaskLocalRNG()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In short, the value 469344150 is used as a seed value in Julia - not &lt;code&gt;1234&lt;/code&gt; - which is the seed value set in R. But the seed used in Julia is a direct derivative of the R seed and thereby controlled via R’s &lt;code&gt;set.seed()&lt;/code&gt; function.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;an-rcpp-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;An Rcpp Example&lt;/h2&gt;
&lt;p&gt;For Rcpp, all steps work as in Julia. Note that I am using the &lt;code&gt;srand()&lt;/code&gt; and &lt;code&gt;rand()&lt;/code&gt; functions, which are actually &lt;a href=&#34;https://stackoverflow.com/questions/26698164/building-r-package-found-rand-possibly-from-rand-c-note-when-checking&#34;&gt;banned for use on CRAN&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s first define a Rcpp based function that randomly samples an integer:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;

//[[Rcpp::export]]
int stochastic_cpp(int seed){
  srand(seed);
  int x = rand();
  return x; 
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stochastic_cpp(seed = 123)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 440&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stochastic_cpp(seed = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can proceed as with the Julia seed:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stochastic_rcpp_fun &amp;lt;- function(seed = NULL){
  
  if(is.null(seed)){
    seed &amp;lt;- sample.int(.Machine$integer.max, 1)
  } else if(!is.null(seed)){
    set.seed(seed)
    seed &amp;lt;- sample.int(.Machine$integer.max, 1)
  }
  
  x &amp;lt;- stochastic_cpp(seed = seed)

  x
  
}

set.seed(1234)
stochastic_rcpp_fun()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 23829&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stochastic_rcpp_fun(seed = 1234)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 23829&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again, we have managed to set the stochastic behavior in the rcpp function via &lt;code&gt;set.seed()&lt;/code&gt; from within R &amp;amp; based on R’s global seed.&lt;/p&gt;
&lt;/div&gt;
</description>    </item>
    
  </channel>
</rss>
